## Task: Settings Persistence

**Objective**: Implement saving modified settings to the appropriate files (config.toml, settings.local.toml, launch.toml).

**Depends on**: 10-setting-editors

**Estimated Time**: 2-2.5 hours

### Scope

- `src/config/settings.rs`: Add `save_settings()` function
- `src/config/launch.rs`: Add `save_launch_configs()` function
- `src/app/handler/update.rs`: Handle `SettingsSave` message

**Related Module:**
```
tui/widgets/settings_panel/
├── mod.rs      # May need updates for save feedback display
├── items.rs    # Item generators used to map changes back to settings
└── tests.rs    # Add persistence integration tests
```

### Details

#### 1. Save Project Settings (config.toml)

```rust
// src/config/settings.rs

/// Save settings to .fdemon/config.toml
///
/// Uses atomic write (temp file + rename) for safety.
/// Preserves existing file structure where possible.
pub fn save_settings(project_path: &Path, settings: &Settings) -> Result<()> {
    let fdemon_dir = project_path.join(FDEMON_DIR);

    // Ensure directory exists
    if !fdemon_dir.exists() {
        std::fs::create_dir_all(&fdemon_dir)
            .map_err(|e| Error::config(format!("Failed to create .fdemon dir: {}", e)))?;
    }

    let config_path = fdemon_dir.join(CONFIG_FILENAME);
    let temp_path = fdemon_dir.join(".config.toml.tmp");

    // Generate TOML content with header
    let header = generate_config_header();
    let content = toml::to_string_pretty(settings)
        .map_err(|e| Error::config(format!("Failed to serialize settings: {}", e)))?;

    let full_content = format!("{}{}", header, content);

    // Atomic write
    std::fs::write(&temp_path, &full_content)
        .map_err(|e| Error::config(format!("Failed to write temp file: {}", e)))?;

    std::fs::rename(&temp_path, &config_path)
        .map_err(|e| Error::config(format!("Failed to rename temp file: {}", e)))?;

    info!("Saved settings to {:?}", config_path);
    Ok(())
}

fn generate_config_header() -> String {
    r#"# Flutter Demon Configuration
# See: https://github.com/example/flutter-demon#configuration
# Generated by fdemon settings panel

"#.to_string()
}
```

#### 2. Save Launch Configurations (launch.toml)

```rust
// src/config/launch.rs

/// Save launch configurations to .fdemon/launch.toml
pub fn save_launch_configs(project_path: &Path, configs: &[LaunchConfig]) -> Result<()> {
    let fdemon_dir = project_path.join(FDEMON_DIR);

    if !fdemon_dir.exists() {
        std::fs::create_dir_all(&fdemon_dir)
            .map_err(|e| Error::config(format!("Failed to create .fdemon dir: {}", e)))?;
    }

    let launch_path = fdemon_dir.join("launch.toml");
    let temp_path = fdemon_dir.join(".launch.toml.tmp");

    let launch_file = LaunchFile {
        configurations: configs.to_vec(),
    };

    let header = generate_launch_header();
    let content = toml::to_string_pretty(&launch_file)
        .map_err(|e| Error::config(format!("Failed to serialize launch configs: {}", e)))?;

    let full_content = format!("{}{}", header, content);

    // Atomic write
    std::fs::write(&temp_path, &full_content)
        .map_err(|e| Error::config(format!("Failed to write temp file: {}", e)))?;

    std::fs::rename(&temp_path, &launch_path)
        .map_err(|e| Error::config(format!("Failed to rename temp file: {}", e)))?;

    info!("Saved launch configs to {:?}", launch_path);
    Ok(())
}

fn generate_launch_header() -> String {
    r#"# Flutter Demon Launch Configurations
# Define multiple launch configurations for different scenarios
# Generated by fdemon settings panel

"#.to_string()
}
```

#### 3. Apply Setting Changes to State

```rust
// Helper function to apply a setting item change to the Settings struct
fn apply_setting_change(settings: &mut Settings, item: &SettingItem) {
    match item.id.as_str() {
        // Behavior
        "behavior.auto_start" => {
            if let SettingValue::Bool(v) = &item.value {
                settings.behavior.auto_start = *v;
            }
        }
        "behavior.confirm_quit" => {
            if let SettingValue::Bool(v) = &item.value {
                settings.behavior.confirm_quit = *v;
            }
        }

        // Watcher
        "watcher.paths" => {
            if let SettingValue::List(v) = &item.value {
                settings.watcher.paths = v.clone();
            }
        }
        "watcher.debounce_ms" => {
            if let SettingValue::Number(v) = &item.value {
                settings.watcher.debounce_ms = *v as u64;
            }
        }
        "watcher.auto_reload" => {
            if let SettingValue::Bool(v) = &item.value {
                settings.watcher.auto_reload = *v;
            }
        }
        "watcher.extensions" => {
            if let SettingValue::List(v) = &item.value {
                settings.watcher.extensions = v.clone();
            }
        }

        // UI
        "ui.log_buffer_size" => {
            if let SettingValue::Number(v) = &item.value {
                settings.ui.log_buffer_size = *v as usize;
            }
        }
        "ui.show_timestamps" => {
            if let SettingValue::Bool(v) = &item.value {
                settings.ui.show_timestamps = *v;
            }
        }
        "ui.compact_logs" => {
            if let SettingValue::Bool(v) = &item.value {
                settings.ui.compact_logs = *v;
            }
        }
        "ui.theme" => {
            if let SettingValue::Enum { value, .. } = &item.value {
                settings.ui.theme = value.clone();
            }
        }
        "ui.stack_trace_collapsed" => {
            if let SettingValue::Bool(v) = &item.value {
                settings.ui.stack_trace_collapsed = *v;
            }
        }
        "ui.stack_trace_max_frames" => {
            if let SettingValue::Number(v) = &item.value {
                settings.ui.stack_trace_max_frames = *v as usize;
            }
        }

        // DevTools
        "devtools.auto_open" => {
            if let SettingValue::Bool(v) = &item.value {
                settings.devtools.auto_open = *v;
            }
        }
        "devtools.browser" => {
            if let SettingValue::String(v) = &item.value {
                settings.devtools.browser = v.clone();
            }
        }

        // Editor
        "editor.command" => {
            if let SettingValue::String(v) = &item.value {
                settings.editor.command = v.clone();
            }
        }
        "editor.open_pattern" => {
            if let SettingValue::String(v) = &item.value {
                settings.editor.open_pattern = v.clone();
            }
        }

        _ => {
            warn!("Unknown setting id: {}", item.id);
        }
    }
}
```

#### 4. Update Handler for Save Message

```rust
// src/app/handler/update.rs

Message::SettingsSave => {
    let result = match state.settings_view_state.active_tab {
        SettingsTab::Project => {
            // Build settings from current items and save
            save_settings(&state.project_path, &state.settings)
        }
        SettingsTab::UserPrefs => {
            save_user_preferences(
                &state.project_path,
                &state.settings_view_state.user_prefs
            )
        }
        SettingsTab::LaunchConfig => {
            let configs: Vec<LaunchConfig> = state.settings_view_state
                .launch_configs
                .iter()
                .map(|r| r.config.clone())
                .collect();
            save_launch_configs(&state.project_path, &configs)
        }
        SettingsTab::VSCodeConfig => {
            // Read-only - nothing to save
            Ok(())
        }
    };

    match result {
        Ok(()) => {
            state.settings_view_state.clear_dirty();
            state.settings_view_state.error = None;
            // TODO: Show success message briefly
        }
        Err(e) => {
            state.settings_view_state.error = Some(format!("Save failed: {}", e));
        }
    }

    UpdateResult::default()
}
```

#### 5. Unsaved Changes Warning

```rust
Message::HideSettings => {
    if state.settings_view_state.dirty {
        // Show confirmation dialog
        state.confirm_dialog_state = Some(ConfirmDialogState::new(
            "Unsaved Changes",
            "You have unsaved changes. Discard them?",
            vec![
                ("Save & Close", Message::SettingsSaveAndClose),
                ("Discard", Message::ForceHideSettings),
                ("Cancel", Message::CancelQuit),
            ],
        ));
        state.ui_mode = UiMode::ConfirmDialog;
    } else {
        state.hide_settings();
    }
    UpdateResult::default()
}

Message::SettingsSaveAndClose => {
    // Save then close
    // (reuse save logic from SettingsSave)
    state.hide_settings();
    UpdateResult::default()
}

Message::ForceHideSettings => {
    state.settings_view_state.clear_dirty();
    state.hide_settings();
    UpdateResult::default()
}
```

### Acceptance Criteria

1. `Ctrl+S` saves current tab's settings to disk
2. Project settings save to `.fdemon/config.toml`
3. User preferences save to `.fdemon/settings.local.toml`
4. Launch configs save to `.fdemon/launch.toml`
5. Atomic writes prevent file corruption
6. Header comments preserved/regenerated in saved files
7. Error messages displayed if save fails
8. Dirty flag cleared after successful save
9. Closing with unsaved changes shows confirmation dialog
10. Unit tests for save/load roundtrip

### Testing

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use tempfile::tempdir;

    #[test]
    fn test_save_settings_roundtrip() {
        let temp = tempdir().unwrap();

        let mut settings = Settings::default();
        settings.behavior.auto_start = true;
        settings.watcher.debounce_ms = 1000;

        // Save
        save_settings(temp.path(), &settings).unwrap();

        // Load
        let loaded = load_settings(temp.path());

        assert!(loaded.behavior.auto_start);
        assert_eq!(loaded.watcher.debounce_ms, 1000);
    }

    #[test]
    fn test_save_creates_directory() {
        let temp = tempdir().unwrap();
        // Don't create .fdemon directory

        let settings = Settings::default();
        save_settings(temp.path(), &settings).unwrap();

        assert!(temp.path().join(".fdemon/config.toml").exists());
    }

    #[test]
    fn test_save_launch_configs_roundtrip() {
        let temp = tempdir().unwrap();

        let configs = vec![
            LaunchConfig {
                name: "Test".to_string(),
                device: "auto".to_string(),
                mode: FlutterMode::Debug,
                ..Default::default()
            }
        ];

        save_launch_configs(temp.path(), &configs).unwrap();

        let loaded = load_launch_configs(temp.path());
        assert_eq!(loaded.len(), 1);
        assert_eq!(loaded[0].config.name, "Test");
    }

    #[test]
    fn test_atomic_write_safety() {
        let temp = tempdir().unwrap();
        std::fs::create_dir_all(temp.path().join(".fdemon")).unwrap();

        // Write initial content
        let settings = Settings::default();
        save_settings(temp.path(), &settings).unwrap();

        // Verify no temp file left behind
        assert!(!temp.path().join(".fdemon/.config.toml.tmp").exists());
    }

    #[test]
    fn test_apply_setting_change() {
        let mut settings = Settings::default();
        assert!(!settings.behavior.auto_start);

        let item = SettingItem::new("behavior.auto_start", "Auto Start")
            .value(SettingValue::Bool(true));

        apply_setting_change(&mut settings, &item);

        assert!(settings.behavior.auto_start);
    }

    #[test]
    fn test_saved_file_has_header() {
        let temp = tempdir().unwrap();
        let settings = Settings::default();

        save_settings(temp.path(), &settings).unwrap();

        let content = std::fs::read_to_string(
            temp.path().join(".fdemon/config.toml")
        ).unwrap();

        assert!(content.contains("Flutter Demon Configuration"));
        assert!(content.contains("#"));
    }
}
```

### Notes

- Atomic writes (temp + rename) prevent file corruption from crashes/interrupts
- Header comments are regenerated on save (user comments are not preserved)
- Consider adding backup before overwrite (future enhancement)
- VSCode tab is read-only so save is a no-op
- Error display uses existing error mechanism in settings panel

---

## Completion Summary

**Status:** Done

### Files Modified

| File | Changes |
|------|---------|
| `src/config/settings.rs` | Added `save_settings()` function with atomic write, `generate_config_header()` helper, and 5 tests for save/load roundtrip |
| `src/config/launch.rs` | Added `save_launch_configs()` function with atomic write, `generate_launch_header()` helper, and 6 tests for save/load roundtrip |
| `src/config/mod.rs` | Exported `save_settings()` and `save_launch_configs()` functions |
| `src/app/handler/settings.rs` | Created new module with `apply_project_setting()`, `apply_user_preference()`, `apply_launch_config_change()` helpers and 11 tests |
| `src/app/handler/mod.rs` | Added `settings` module export |
| `src/app/handler/update.rs` | Implemented `SettingsSave` handler with tab-specific save logic, updated `HideSettings` to show confirmation dialog on dirty state, added `SettingsSaveAndClose` and `ForceHideSettings` handlers |
| `src/app/message.rs` | Added `SettingsSaveAndClose` and `ForceHideSettings` messages |
| `src/tui/widgets/confirm_dialog.rs` | Added generic `new()` constructor to `ConfirmDialogState` with options support |

### Notable Decisions/Tradeoffs

1. **Atomic Writes**: Used temp file + rename pattern for all save operations to prevent file corruption from crashes or interrupts
2. **Header Regeneration**: Headers are regenerated on each save rather than preserving user comments - simplifies implementation and ensures consistency
3. **Tab-Specific Save**: Save operation only affects the currently active tab (Project/UserPrefs/Launch), not all tabs at once
4. **Error Display**: Save errors are displayed in the settings panel's error field rather than as a separate modal
5. **Confirmation Dialog Enhancement**: Extended ConfirmDialogState to support generic confirmation dialogs with custom options, not just quit confirmation
6. **No Backup Files**: Currently no backup before overwrite - could be added as future enhancement
7. **Launch Config Save Limitation**: Saves entire launch config list as-is from disk rather than tracking individual changes - simpler but may lose in-memory edits if not committed

### Testing Performed

- `cargo fmt` - Passed
- `cargo check` - Passed
- `cargo clippy` - Passed (25 pre-existing warnings, none new)
- `cargo test --lib` - Passed (1054 tests)
- `cargo test config::settings::tests::test_save` - Passed (7 tests)
- `cargo test config::launch::tests::test_save` - Passed (6 tests)
- `cargo test handler::settings` - Passed (11 tests)

### Risks/Limitations

1. **Launch Config Changes Not Applied Yet**: While save functionality works, there's no mechanism yet to apply in-memory changes from the settings panel back to the LaunchConfig structs before saving - this will need to be addressed in the settings editing task
2. **No Transaction Support**: Each tab saves independently - if multiple tabs have changes, they must be saved separately
3. **VSCode Tab Read-Only**: Save on VSCode tab is a no-op as expected, but no visual indication beyond existing read-only styling
