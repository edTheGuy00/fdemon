## Task: Settings Persistence

**Objective**: Implement saving modified settings to the appropriate files (config.toml, settings.local.toml, launch.toml).

**Depends on**: 10-setting-editors

**Estimated Time**: 2-2.5 hours

### Scope

- `src/config/settings.rs`: Add `save_settings()` function
- `src/config/launch.rs`: Add `save_launch_configs()` function
- `src/app/handler/update.rs`: Handle `SettingsSave` message

### Details

#### 1. Save Project Settings (config.toml)

```rust
// src/config/settings.rs

/// Save settings to .fdemon/config.toml
///
/// Uses atomic write (temp file + rename) for safety.
/// Preserves existing file structure where possible.
pub fn save_settings(project_path: &Path, settings: &Settings) -> Result<()> {
    let fdemon_dir = project_path.join(FDEMON_DIR);

    // Ensure directory exists
    if !fdemon_dir.exists() {
        std::fs::create_dir_all(&fdemon_dir)
            .map_err(|e| Error::config(format!("Failed to create .fdemon dir: {}", e)))?;
    }

    let config_path = fdemon_dir.join(CONFIG_FILENAME);
    let temp_path = fdemon_dir.join(".config.toml.tmp");

    // Generate TOML content with header
    let header = generate_config_header();
    let content = toml::to_string_pretty(settings)
        .map_err(|e| Error::config(format!("Failed to serialize settings: {}", e)))?;

    let full_content = format!("{}{}", header, content);

    // Atomic write
    std::fs::write(&temp_path, &full_content)
        .map_err(|e| Error::config(format!("Failed to write temp file: {}", e)))?;

    std::fs::rename(&temp_path, &config_path)
        .map_err(|e| Error::config(format!("Failed to rename temp file: {}", e)))?;

    info!("Saved settings to {:?}", config_path);
    Ok(())
}

fn generate_config_header() -> String {
    r#"# Flutter Demon Configuration
# See: https://github.com/example/flutter-demon#configuration
# Generated by fdemon settings panel

"#.to_string()
}
```

#### 2. Save Launch Configurations (launch.toml)

```rust
// src/config/launch.rs

/// Save launch configurations to .fdemon/launch.toml
pub fn save_launch_configs(project_path: &Path, configs: &[LaunchConfig]) -> Result<()> {
    let fdemon_dir = project_path.join(FDEMON_DIR);

    if !fdemon_dir.exists() {
        std::fs::create_dir_all(&fdemon_dir)
            .map_err(|e| Error::config(format!("Failed to create .fdemon dir: {}", e)))?;
    }

    let launch_path = fdemon_dir.join("launch.toml");
    let temp_path = fdemon_dir.join(".launch.toml.tmp");

    let launch_file = LaunchFile {
        configurations: configs.to_vec(),
    };

    let header = generate_launch_header();
    let content = toml::to_string_pretty(&launch_file)
        .map_err(|e| Error::config(format!("Failed to serialize launch configs: {}", e)))?;

    let full_content = format!("{}{}", header, content);

    // Atomic write
    std::fs::write(&temp_path, &full_content)
        .map_err(|e| Error::config(format!("Failed to write temp file: {}", e)))?;

    std::fs::rename(&temp_path, &launch_path)
        .map_err(|e| Error::config(format!("Failed to rename temp file: {}", e)))?;

    info!("Saved launch configs to {:?}", launch_path);
    Ok(())
}

fn generate_launch_header() -> String {
    r#"# Flutter Demon Launch Configurations
# Define multiple launch configurations for different scenarios
# Generated by fdemon settings panel

"#.to_string()
}
```

#### 3. Apply Setting Changes to State

```rust
// Helper function to apply a setting item change to the Settings struct
fn apply_setting_change(settings: &mut Settings, item: &SettingItem) {
    match item.id.as_str() {
        // Behavior
        "behavior.auto_start" => {
            if let SettingValue::Bool(v) = &item.value {
                settings.behavior.auto_start = *v;
            }
        }
        "behavior.confirm_quit" => {
            if let SettingValue::Bool(v) = &item.value {
                settings.behavior.confirm_quit = *v;
            }
        }

        // Watcher
        "watcher.paths" => {
            if let SettingValue::List(v) = &item.value {
                settings.watcher.paths = v.clone();
            }
        }
        "watcher.debounce_ms" => {
            if let SettingValue::Number(v) = &item.value {
                settings.watcher.debounce_ms = *v as u64;
            }
        }
        "watcher.auto_reload" => {
            if let SettingValue::Bool(v) = &item.value {
                settings.watcher.auto_reload = *v;
            }
        }
        "watcher.extensions" => {
            if let SettingValue::List(v) = &item.value {
                settings.watcher.extensions = v.clone();
            }
        }

        // UI
        "ui.log_buffer_size" => {
            if let SettingValue::Number(v) = &item.value {
                settings.ui.log_buffer_size = *v as usize;
            }
        }
        "ui.show_timestamps" => {
            if let SettingValue::Bool(v) = &item.value {
                settings.ui.show_timestamps = *v;
            }
        }
        "ui.compact_logs" => {
            if let SettingValue::Bool(v) = &item.value {
                settings.ui.compact_logs = *v;
            }
        }
        "ui.theme" => {
            if let SettingValue::Enum { value, .. } = &item.value {
                settings.ui.theme = value.clone();
            }
        }
        "ui.stack_trace_collapsed" => {
            if let SettingValue::Bool(v) = &item.value {
                settings.ui.stack_trace_collapsed = *v;
            }
        }
        "ui.stack_trace_max_frames" => {
            if let SettingValue::Number(v) = &item.value {
                settings.ui.stack_trace_max_frames = *v as usize;
            }
        }

        // DevTools
        "devtools.auto_open" => {
            if let SettingValue::Bool(v) = &item.value {
                settings.devtools.auto_open = *v;
            }
        }
        "devtools.browser" => {
            if let SettingValue::String(v) = &item.value {
                settings.devtools.browser = v.clone();
            }
        }

        // Editor
        "editor.command" => {
            if let SettingValue::String(v) = &item.value {
                settings.editor.command = v.clone();
            }
        }
        "editor.open_pattern" => {
            if let SettingValue::String(v) = &item.value {
                settings.editor.open_pattern = v.clone();
            }
        }

        _ => {
            warn!("Unknown setting id: {}", item.id);
        }
    }
}
```

#### 4. Update Handler for Save Message

```rust
// src/app/handler/update.rs

Message::SettingsSave => {
    let result = match state.settings_view_state.active_tab {
        SettingsTab::Project => {
            // Build settings from current items and save
            save_settings(&state.project_path, &state.settings)
        }
        SettingsTab::UserPrefs => {
            save_user_preferences(
                &state.project_path,
                &state.settings_view_state.user_prefs
            )
        }
        SettingsTab::LaunchConfig => {
            let configs: Vec<LaunchConfig> = state.settings_view_state
                .launch_configs
                .iter()
                .map(|r| r.config.clone())
                .collect();
            save_launch_configs(&state.project_path, &configs)
        }
        SettingsTab::VSCodeConfig => {
            // Read-only - nothing to save
            Ok(())
        }
    };

    match result {
        Ok(()) => {
            state.settings_view_state.clear_dirty();
            state.settings_view_state.error = None;
            // TODO: Show success message briefly
        }
        Err(e) => {
            state.settings_view_state.error = Some(format!("Save failed: {}", e));
        }
    }

    UpdateResult::default()
}
```

#### 5. Unsaved Changes Warning

```rust
Message::HideSettings => {
    if state.settings_view_state.dirty {
        // Show confirmation dialog
        state.confirm_dialog_state = Some(ConfirmDialogState::new(
            "Unsaved Changes",
            "You have unsaved changes. Discard them?",
            vec![
                ("Save & Close", Message::SettingsSaveAndClose),
                ("Discard", Message::ForceHideSettings),
                ("Cancel", Message::CancelQuit),
            ],
        ));
        state.ui_mode = UiMode::ConfirmDialog;
    } else {
        state.hide_settings();
    }
    UpdateResult::default()
}

Message::SettingsSaveAndClose => {
    // Save then close
    // (reuse save logic from SettingsSave)
    state.hide_settings();
    UpdateResult::default()
}

Message::ForceHideSettings => {
    state.settings_view_state.clear_dirty();
    state.hide_settings();
    UpdateResult::default()
}
```

### Acceptance Criteria

1. `Ctrl+S` saves current tab's settings to disk
2. Project settings save to `.fdemon/config.toml`
3. User preferences save to `.fdemon/settings.local.toml`
4. Launch configs save to `.fdemon/launch.toml`
5. Atomic writes prevent file corruption
6. Header comments preserved/regenerated in saved files
7. Error messages displayed if save fails
8. Dirty flag cleared after successful save
9. Closing with unsaved changes shows confirmation dialog
10. Unit tests for save/load roundtrip

### Testing

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use tempfile::tempdir;

    #[test]
    fn test_save_settings_roundtrip() {
        let temp = tempdir().unwrap();

        let mut settings = Settings::default();
        settings.behavior.auto_start = true;
        settings.watcher.debounce_ms = 1000;

        // Save
        save_settings(temp.path(), &settings).unwrap();

        // Load
        let loaded = load_settings(temp.path());

        assert!(loaded.behavior.auto_start);
        assert_eq!(loaded.watcher.debounce_ms, 1000);
    }

    #[test]
    fn test_save_creates_directory() {
        let temp = tempdir().unwrap();
        // Don't create .fdemon directory

        let settings = Settings::default();
        save_settings(temp.path(), &settings).unwrap();

        assert!(temp.path().join(".fdemon/config.toml").exists());
    }

    #[test]
    fn test_save_launch_configs_roundtrip() {
        let temp = tempdir().unwrap();

        let configs = vec![
            LaunchConfig {
                name: "Test".to_string(),
                device: "auto".to_string(),
                mode: FlutterMode::Debug,
                ..Default::default()
            }
        ];

        save_launch_configs(temp.path(), &configs).unwrap();

        let loaded = load_launch_configs(temp.path());
        assert_eq!(loaded.len(), 1);
        assert_eq!(loaded[0].config.name, "Test");
    }

    #[test]
    fn test_atomic_write_safety() {
        let temp = tempdir().unwrap();
        std::fs::create_dir_all(temp.path().join(".fdemon")).unwrap();

        // Write initial content
        let settings = Settings::default();
        save_settings(temp.path(), &settings).unwrap();

        // Verify no temp file left behind
        assert!(!temp.path().join(".fdemon/.config.toml.tmp").exists());
    }

    #[test]
    fn test_apply_setting_change() {
        let mut settings = Settings::default();
        assert!(!settings.behavior.auto_start);

        let item = SettingItem::new("behavior.auto_start", "Auto Start")
            .value(SettingValue::Bool(true));

        apply_setting_change(&mut settings, &item);

        assert!(settings.behavior.auto_start);
    }

    #[test]
    fn test_saved_file_has_header() {
        let temp = tempdir().unwrap();
        let settings = Settings::default();

        save_settings(temp.path(), &settings).unwrap();

        let content = std::fs::read_to_string(
            temp.path().join(".fdemon/config.toml")
        ).unwrap();

        assert!(content.contains("Flutter Demon Configuration"));
        assert!(content.contains("#"));
    }
}
```

### Notes

- Atomic writes (temp + rename) prevent file corruption from crashes/interrupts
- Header comments are regenerated on save (user comments are not preserved)
- Consider adding backup before overwrite (future enhancement)
- VSCode tab is read-only so save is a no-op
- Error display uses existing error mechanism in settings panel

---

## Completion Summary

**Status:** (Not Started)

**Files Modified:**
- (To be filled after implementation)

**Implementation Details:**

(To be filled after implementation)

**Testing Performed:**
- `cargo fmt` -
- `cargo check` -
- `cargo clippy -- -D warnings` -
- `cargo test settings` -

**Notable Decisions:**
- (To be filled after implementation)
