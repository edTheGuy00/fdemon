# Task: Launch Config Editing (launch.toml)

**Objective**: Enable creating, editing, and deleting launch configurations in `.fdemon/launch.toml` from the settings panel.

**Depends on**: None (independent task)

## Scope

- `src/config/launch.rs` — Add save/create/delete functions
- `src/tui/widgets/settings_panel/items.rs` — Handle config editing
- `src/app/message.rs` — Add config editing messages
- `src/app/handler/mod.rs` — Handle config editing messages

## Details

### Config Persistence Functions

Add to `src/config/launch.rs`:

```rust
use std::io::Write;

/// Save launch configurations to .fdemon/launch.toml
///
/// Overwrites existing file with new configs.
pub fn save_launch_configs(project_path: &Path, configs: &[LaunchConfig]) -> Result<()> {
    let fdemon_dir = project_path.join(".fdemon");

    // Ensure directory exists
    if !fdemon_dir.exists() {
        std::fs::create_dir_all(&fdemon_dir)
            .map_err(|e| Error::config(format!("Failed to create .fdemon dir: {}", e)))?;
    }

    let launch_path = fdemon_dir.join("launch.toml");
    let temp_path = fdemon_dir.join(".launch.toml.tmp");

    // Build TOML content
    let content = build_launch_toml(configs);

    // Atomic write: temp file + rename
    std::fs::write(&temp_path, &content)
        .map_err(|e| Error::config(format!("Failed to write temp file: {}", e)))?;

    std::fs::rename(&temp_path, &launch_path)
        .map_err(|e| Error::config(format!("Failed to rename temp file: {}", e)))?;

    info!("Saved {} launch configuration(s) to {:?}", configs.len(), launch_path);
    Ok(())
}

fn build_launch_toml(configs: &[LaunchConfig]) -> String {
    let mut content = String::from(
        "# Flutter Demon Launch Configurations\n\
         # Generated by fdemon settings panel\n\n"
    );

    for config in configs {
        content.push_str("[[configurations]]\n");
        content.push_str(&format!("name = \"{}\"\n", config.name));
        content.push_str(&format!("device = \"{}\"\n", config.device));
        content.push_str(&format!("mode = \"{}\"\n", config.mode));

        if let Some(ref flavor) = config.flavor {
            content.push_str(&format!("flavor = \"{}\"\n", flavor));
        }

        if config.auto_start {
            content.push_str("auto_start = true\n");
        }

        if !config.dart_defines.is_empty() {
            content.push_str("[configurations.dart_defines]\n");
            for (key, value) in &config.dart_defines {
                content.push_str(&format!("{} = \"{}\"\n", key, value));
            }
        }

        if !config.args.is_empty() {
            content.push_str(&format!("args = {:?}\n", config.args));
        }

        content.push('\n');
    }

    content
}

/// Create a new launch configuration with sensible defaults
pub fn create_default_launch_config() -> LaunchConfig {
    LaunchConfig {
        name: "New Configuration".to_string(),
        device: "auto".to_string(),
        mode: FlutterMode::Debug,
        flavor: None,
        dart_defines: HashMap::new(),
        args: Vec::new(),
        auto_start: false,
    }
}

/// Delete a launch configuration by name
///
/// Reloads configs, removes matching one, saves back.
pub fn delete_launch_config(project_path: &Path, config_name: &str) -> Result<()> {
    let mut configs: Vec<LaunchConfig> = load_launch_configs(project_path)
        .into_iter()
        .map(|r| r.config)
        .collect();

    let initial_len = configs.len();
    configs.retain(|c| c.name != config_name);

    if configs.len() == initial_len {
        return Err(Error::config(format!("Config '{}' not found", config_name)));
    }

    save_launch_configs(project_path, &configs)
}

/// Update a specific field of a launch configuration
pub fn update_launch_config_field(
    project_path: &Path,
    config_name: &str,
    field: &str,
    value: &str,
) -> Result<()> {
    let mut configs: Vec<LaunchConfig> = load_launch_configs(project_path)
        .into_iter()
        .map(|r| r.config)
        .collect();

    let config = configs
        .iter_mut()
        .find(|c| c.name == config_name)
        .ok_or_else(|| Error::config(format!("Config '{}' not found", config_name)))?;

    match field {
        "name" => config.name = value.to_string(),
        "device" => config.device = value.to_string(),
        "mode" => {
            config.mode = match value.to_lowercase().as_str() {
                "debug" => FlutterMode::Debug,
                "profile" => FlutterMode::Profile,
                "release" => FlutterMode::Release,
                _ => return Err(Error::config(format!("Invalid mode: {}", value))),
            };
        }
        "flavor" => {
            config.flavor = if value.is_empty() {
                None
            } else {
                Some(value.to_string())
            };
        }
        "auto_start" => {
            config.auto_start = value.to_lowercase() == "true";
        }
        _ => return Err(Error::config(format!("Unknown field: {}", field))),
    }

    save_launch_configs(project_path, &configs)
}

/// Add a new launch configuration
pub fn add_launch_config(project_path: &Path, config: LaunchConfig) -> Result<()> {
    let mut configs: Vec<LaunchConfig> = load_launch_configs(project_path)
        .into_iter()
        .map(|r| r.config)
        .collect();

    // Ensure unique name
    let base_name = config.name.clone();
    let mut new_config = config;
    let mut counter = 1;

    while configs.iter().any(|c| c.name == new_config.name) {
        new_config.name = format!("{} ({})", base_name, counter);
        counter += 1;
    }

    configs.push(new_config);
    save_launch_configs(project_path, &configs)
}
```

### New Messages

Add to `src/app/message.rs`:

```rust
// ─────────────────────────────────────────────────────────────
// Launch Config Editing Messages (Phase 5)
// ─────────────────────────────────────────────────────────────
/// Create a new launch configuration
LaunchConfigCreate,

/// Delete launch configuration at index
LaunchConfigDelete(usize),

/// Update a field of launch configuration
LaunchConfigUpdate {
    config_idx: usize,
    field: String,
    value: String,
},
```

### Settings Panel Integration

Update handling for "n" key in launch config tab (`items.rs`):

```rust
// In LaunchConfig tab handling
KeyCode::Char('n') => {
    // Create new config with defaults
    Some(Message::LaunchConfigCreate)
}

KeyCode::Char('d') | KeyCode::Delete => {
    // Delete selected config (with confirmation)
    if let Some(idx) = state.selected_index {
        Some(Message::LaunchConfigDelete(idx))
    } else {
        None
    }
}
```

### Message Handlers

Add to `src/app/handler/mod.rs`:

```rust
Message::LaunchConfigCreate => {
    let new_config = config::create_default_launch_config();
    if let Err(e) = config::add_launch_config(&state.project_path, new_config) {
        state.settings_view_state.error = Some(format!("Failed to create config: {}", e));
    } else {
        // Reload configs in settings view
        state.settings_view_state.mark_dirty();
    }
    None
}

Message::LaunchConfigDelete(idx) => {
    // Get config name at index
    let configs = config::load_launch_configs(&state.project_path);
    if let Some(resolved) = configs.get(idx) {
        if let Err(e) = config::delete_launch_config(&state.project_path, &resolved.config.name) {
            state.settings_view_state.error = Some(format!("Failed to delete: {}", e));
        } else {
            state.settings_view_state.mark_dirty();
        }
    }
    None
}

Message::LaunchConfigUpdate { config_idx, field, value } => {
    let configs = config::load_launch_configs(&state.project_path);
    if let Some(resolved) = configs.get(config_idx) {
        if let Err(e) = config::update_launch_config_field(
            &state.project_path,
            &resolved.config.name,
            &field,
            &value,
        ) {
            state.settings_view_state.error = Some(format!("Failed to update: {}", e));
        } else {
            state.settings_view_state.mark_dirty();
        }
    }
    None
}
```

## Acceptance Criteria

1. "n" key creates new config with default values
2. New config name is unique (appends counter if needed)
3. "d" key deletes selected config
4. Enter on editable field allows editing
5. Changes persist to `.fdemon/launch.toml`
6. File format matches expected TOML structure
7. Atomic write prevents corruption

## Testing

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use tempfile::tempdir;

    #[test]
    fn test_save_launch_configs() {
        let temp = tempdir().unwrap();

        let configs = vec![
            LaunchConfig {
                name: "Debug".to_string(),
                device: "auto".to_string(),
                mode: FlutterMode::Debug,
                flavor: Some("dev".to_string()),
                dart_defines: HashMap::from([
                    ("API_URL".to_string(), "https://dev.api.com".to_string()),
                ]),
                args: vec!["--verbose".to_string()],
                auto_start: true,
            },
        ];

        save_launch_configs(temp.path(), &configs).unwrap();

        // Verify file exists
        assert!(temp.path().join(".fdemon/launch.toml").exists());

        // Reload and verify
        let loaded = load_launch_configs(temp.path());
        assert_eq!(loaded.len(), 1);
        assert_eq!(loaded[0].config.name, "Debug");
        assert_eq!(loaded[0].config.flavor, Some("dev".to_string()));
        assert!(loaded[0].config.auto_start);
    }

    #[test]
    fn test_add_launch_config_unique_name() {
        let temp = tempdir().unwrap();

        // Add first config
        let config1 = LaunchConfig {
            name: "Debug".to_string(),
            ..Default::default()
        };
        add_launch_config(temp.path(), config1).unwrap();

        // Add second with same name
        let config2 = LaunchConfig {
            name: "Debug".to_string(),
            ..Default::default()
        };
        add_launch_config(temp.path(), config2).unwrap();

        // Should have unique names
        let loaded = load_launch_configs(temp.path());
        assert_eq!(loaded.len(), 2);
        assert_eq!(loaded[0].config.name, "Debug");
        assert_eq!(loaded[1].config.name, "Debug (1)");
    }

    #[test]
    fn test_delete_launch_config() {
        let temp = tempdir().unwrap();

        // Add two configs
        save_launch_configs(
            temp.path(),
            &[
                LaunchConfig { name: "Debug".to_string(), ..Default::default() },
                LaunchConfig { name: "Release".to_string(), ..Default::default() },
            ],
        ).unwrap();

        // Delete one
        delete_launch_config(temp.path(), "Debug").unwrap();

        // Verify
        let loaded = load_launch_configs(temp.path());
        assert_eq!(loaded.len(), 1);
        assert_eq!(loaded[0].config.name, "Release");
    }

    #[test]
    fn test_update_launch_config_field() {
        let temp = tempdir().unwrap();

        save_launch_configs(
            temp.path(),
            &[LaunchConfig { name: "Debug".to_string(), ..Default::default() }],
        ).unwrap();

        // Update mode
        update_launch_config_field(temp.path(), "Debug", "mode", "release").unwrap();

        // Verify
        let loaded = load_launch_configs(temp.path());
        assert_eq!(loaded[0].config.mode, FlutterMode::Release);
    }

    #[test]
    fn test_create_default_launch_config() {
        let config = create_default_launch_config();

        assert_eq!(config.name, "New Configuration");
        assert_eq!(config.device, "auto");
        assert_eq!(config.mode, FlutterMode::Debug);
        assert!(!config.auto_start);
    }
}
```

## Notes

- launch.json remains read-only (VSCode manages it)
- Atomic write prevents file corruption on crash
- Settings panel reloads configs after changes
- Future: could add inline editing in settings panel

---

## Completion Summary

**Status:** Not Started

**Files Modified:**
- (none yet)

**Implementation Details:**
(to be filled after implementation)

**Testing Performed:**
- `cargo fmt` - Pending
- `cargo check` - Pending
- `cargo clippy -- -D warnings` - Pending
- `cargo test launch` - Pending
